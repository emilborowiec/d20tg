@using d20TG.Features.ScenarioSetup.Services
@using d20TG.Features.ScenarioSetup.State
@using d20TG.Features.CombatSimulations
@using d20TG.Domain
@using d20TG.Features.ScenarioSetup.Utils
@attribute [Route(MyRoutes.ScenarioSimulationRoute)]
@inject ICombatScenarioRepository ScenarioRepository

<h3>ScenarioSimulation</h3>

@if (_scenarioState != null)
{
    <CombatScenarioStateView ScenarioState="@_scenarioState.Value"/>

    <input type="number" min="1" max="100" @bind="RunCount"/>
    <button @onclick="HandleRunSimulationsClick">Run Simulation</button>

    @for (var i = 0; i < _runs.Count; i++)
    {
        <h3>Run: @i</h3>
        <table>
            <thead>
            <tr>Course of Combat</tr>
            </thead>
            @foreach (var round in _runs[i].Rounds)
            {
                <tbody>
                @foreach (var turn in round.Turns)
                {
                    <tr>
                        <td rowspan="@round.Turns.Count">@(round.RoundNumber + 1)</td>
                        <td>@turn.Defence</td>
                        <td>@turn.Attack</td>
                        <td>@turn.Damage</td>
                    </tr>
                }
                </tbody>
            }
        </table>
    }

    @if (_runs.Count > 0)
    {
        <h2>Rounds to beat distribution: </h2>
        @foreach (var kvPair in GetRoundsToBeatDistribution(_runs))
        {
            <p>@kvPair.Key rounds: @kvPair.Value runs</p>
        }
    }
}
else
{
    <p>Scenario not found or expired!</p>
}


@code {

    [Parameter]
    public string? ScenarioId { get; set; }

    public int RunCount { get; set; } = 20;

    private CombatScenarioState? _scenarioState;
    private List<SimulationRun> _runs = new();

    private static Dictionary<int, int> GetRoundsToBeatDistribution(IEnumerable<SimulationRun> runs)
    {
        return runs.GroupBy(x => x.Rounds.Count).ToDictionary(x => x.Key, x => x.Count());
    }

    protected override async Task OnParametersSetAsync()
    {
        if (ScenarioId == null)
        {
            return;
        }

        var scenario = await ScenarioRepository.LoadScenarioAsync(ScenarioId);
        Console.WriteLine($"Loaded scenario: {ScenarioId} {scenario}");
        _scenarioState = scenario.ToReadOnlyState();

        await base.OnParametersSetAsync();
    }

    private class SimulationRun
    {
        public List<CombatRound> Rounds { get; } = new();
    }

    private List<SimulationRun> RunSimulations(int runCount, CombatScenarioState combatScenarioState)
    {
        var runs = new List<SimulationRun>();
        for (var i = 0; i < runCount; i++)
        {
            var run = RunSimulation(combatScenarioState);
            runs.Add(run);
        }
        return runs;
    }

    private SimulationRun RunSimulation(CombatScenarioState combatScenarioState)
    {
        var run = new SimulationRun();
        var roundNumber = 0;
        var attackers = combatScenarioState.AttackerBuildStates.Select(x => new Attacker(x)).ToArray();
        var defenders = combatScenarioState.DefenderBuildStates.Select(x => new Defender(x)).ToArray();
        while (AnyoneAlive(defenders))
        {
            var round = new CombatRound(roundNumber);
            run.Rounds.Add(round);
            foreach (var attacker in attackers)
            {
                var target = FindLivingDefender(defenders);
                var attackRoll = CombatSystem.RollD20();
                var isHit = CombatSystem.IsHit(target.Build.ArmorClass, attacker.Build.AttackBonus, attackRoll);
                var turn = new CombatTurn(attacker, target, attackRoll);
                round.Turns.Add(turn);
                if (isHit)
                {
                    var damage = CombatSystem.RollDamage(attacker.Build.DamageDiceState.DiceCount, attacker.Build.DamageBonus, attacker.Build.DamageDiceState.DiceType, out var damageRolls);
                    target.CurrentHitPoints -= damage;
                    turn.DamageRolls = damageRolls;
                }
                if (!AnyoneAlive(defenders))
                {
                    break;
                }
            }
            roundNumber++;
        }

        return run;
    }

    private static Defender FindLivingDefender(IEnumerable<Defender> defenders)
    {
        return defenders.First(x => x.Alive);
    }

    private static bool AnyoneAlive(IEnumerable<Defender> defenders)
    {
        return defenders.Any(defender => defender.Alive);
    }

    private void HandleRunSimulationsClick()
    {
        if (_scenarioState == null)
        {
            return;
        }

        _runs = RunSimulations(RunCount, _scenarioState.Value);
    }
}